#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""A script that starts a vm, reverts it to a known snapshot, tests a
submission bundle (submission + tests), and closes the vm"""

from __future__ import with_statement


# Use simplejson or Python 2.6 json, prefer simplejson.
try:
    import simplejson as json
except ImportError:
    import json

import os
import sys
import time
import logging
import signal
import ConfigParser
import shlex
from threading import Thread
from subprocess import Popen, PIPE, STDOUT

from vmchecker.config import VmwareMachineConfig, CourseConfig, VmwareConfig

_logger = logging.getLogger('vm_executor')



class Host():
    def __init__(self):
        pass

    def executeCommand(self, cmd):
        print "CMD: "+cmd
        p = Popen([cmd],stdout=PIPE,shell=True)
        output = p.stdout.read()
        print "OUT: "+output
        return output

    def getVM(self, machinecfg):
        vm = VM(self, machinecfg)
        return None
	
		    
class VM():
    host 	= None
    path 	= None
    vmtype 	= None
    username	= None
    password	= None
    IP	= None
    
    def __init__(self, host, machinecfg):
	    self.host = host
	    self.username = machinecfg.guest_user()
	    self.password = machinecfg.guest_pass()
	    
	    # TODO check if path exists

    def executeCommand(self, cmd):
	    # host.executeCommand(...)
	    pass

    def executeNativeCommand(self, cmd):
	    # there is no default need for native commands
	    return self.executeCommand(cmd)

    def hasStarted(self):
        return False
	
    def start(self):
        pass
        
    def stop(self):
        pass
        
    def revert(self, number = None):
        pass
        
    def copyTo(self, targetDir, sourceDir, files):
        pass
    
    def copyFrom(self, targetDir, sourceDir, files):
        pass
        
    def run(self, executable_file, shell=None, timeout=None):
        pass
        
    def runTest(self, bundle_dir, machinecfg, test):
        """ originally named  def copy_files_and_run_script(vm, bundle_dir, machinecfg, test) """
        try:
            files_to_copy = test['input'] + test['script']
            guest_dest_dir = machinecfg.guest_base_path()
            self.copyTo(bundle_dir,guest_dest_dir,files_to_copy)
            for script in test['script']:
                shell = machinecfg.guest_shell_path()
                dest_in_guest_shell = machinecfg.guest_home_in_shell()
                script_in_guest_shell = dest_in_guest_shell  + script
                timedout = self.run(shell,script_in_guest_shell,test['timeout'])
                self.copyFrom(guest_dest_dir,bundle_dir,test['output'])
                if timedout:
                    return False
        except:
            _logger.exception('error in copy_files_and_run_script')
        finally:
            return True


class LXCVM(VM):
    hostname = 'deb1'
    #hostpath = '/var/lib/lxc/'+hostname
    def executeCommand(self,cmd):
        return self.host.executeCommand("ssh "+self.username+"@"+self.hostname+" "+cmd)
    
    def start(self):
        self.host.executeCommand("lxc-start -n "+self.hostname+" -d")
        while True:
            if self.hasStarted():
                return
    
    def stop(self):
        self.host.executeCommand("lxc-stop -n "+self.hostname)

    def hasStarted(self):
        o = self.host.executeCommand("lxc-info -n "+self.hostname)
        if "-1" in o:
            return False
        if "refused" in self.executeCommand('echo hello'):
            return False
        return True
            
    
    def revert(self, number = None):
        '''
        TODO:
        1. replace hardcoded paths with configurable options
        2. provide a way for starting multiple containters at the same time
        '''
        self.host.executeCommand("lxc-stop -n "+self.hostname)
        self.host.executeCommand("rm -rf /var/lib/lxc/"+self.hostname+"/rootfs")
        self.host.executeCommand("cp -pr /lxc/rootfs /var/lib/lxc/"+self.hostname)
        self.start()
       
    def copyTo(self, sourceDir, targetDir, files):
        """ Copy files from host(source) to guest(target) """
        for f in files:
            host_path = os.path.join(sourceDir, f)
            guest_path = os.path.join(targetDir, f)
            guest_path = "/var/lib/lxc/"+self.hostname+"/rootfs"+guest_path
            if not os.path.exists(host_path):
                _logger.error('host file (to send) "%s" does not exist' % host_path)
                return
            _logger.info('copy file %s from host to guest at %s' % (host_path, guest_path))
            self.host.executeCommand("cp %s %s" % (host_path,guest_path))
        
    def copyFrom(self, sourceDir, targetDir, files):
        """ Copy files from guest(source) to host(target) """
        for f in files:
            host_path = os.path.join(targetDir, f)
            guest_path = os.path.join(sourceDir, f)
            guest_path = "/var/lib/lxc/"+self.hostname+"/rootfs"+guest_path
            print "host path: "+host_path
            print "guest path: "+guest_path
            _logger.info('copy file %s from guest to host at %s' % (guest_path, host_path))
            self.host.executeCommand("cp %s %s" % (guest_path,host_path))
            if not os.path.exists(host_path):
                _logger.error('host file (received) "%s" does not exist' % host_path)

    def run(self, shell, executable_file, timeout ):
        self.executeCommand("chmod +x "+ executable_file)
        print "####"+executable_file
        _logger.info('executing on the remote: prog=%s args=[%s] timeout=%d' % (shell, executable_file, timeout))
        thd = Thread(target = self.executeCommand, args = (executable_file,))
        thd.start()
        if timeout==None:
            thd.join()
        else:
            thd.join(timeout)
        return thd.isAlive() 
        
class LXCHost(Host):
    def getVM(self, machinecfg):
        return LXCVM(self, machinecfg)

def copy_files_and_run_script(vm, bundle_dir, machinecfg, test):
    return vm.runTest(bundle_dir, machinecfg, test)
    
def start_host_commands(jobs_path, host_command):
    """Run a command on the tester (host) machine"""
    _logger.info('%%% -- starting host commands [' + host_command + ']')

    if len(host_command) == 0:
        return None

    outf = open(os.path.join(jobs_path, 'run-km.vmr'), 'a')
    try:
        proc = Popen(host_command, stdout=outf, shell=True)
    except:
        _logger.exception('HOSTPROC: opening process: ' + host_command)
    return (proc, outf)


def stop_host_commands(host_command_data):
    """Stop previously run host commands"""
    if host_command_data == None:
        return

    (proc, outf) = host_command_data
    try:
        os.kill(proc.pid, signal.SIGTERM)
        outf.close()
    except:
        _logger.exception('HOSTPROC: while stopping host cmds')
    _logger.info("%%% -- stopped host commands")


def _wait_for_tools(vm):
    """Called by the thread that waits for the VMWare Tools to
       start. If the Tools do not start, there is no direct way of
       ending the Thread.  As a result, on powerOff(), the Thread
       would throw a VIXException on account of the VM not being
       powered on.
    """
    try:
        #vm.waitForToolsInGuest()
        # TODO : check if lxc-machine has started
        while True:
            o = hostRun("lxc-info -n deb1")
            if not "-1" in o:
                return
        pass
    except:
        pass


def wait_for_tools_with_timeout(vm, timeout, error_fname):
    """Wait for VMWare Tools to start.

    Returns True on success and False when the VMWare tools did not
    start properly in the given timeout. Writes error messages to
    `error_fname`.
    """
    # TODO
    # not needed
    if timeout != None:
        timeout = int(timeout)
        _logger.info('Waiting for VMWare Tools with a timeout of %d seconds' % timeout)

    tools_thd = Thread(target = _wait_for_tools, args=(vm,))
    tools_thd.start()
    # normally the thread will end before the timeout expires, so a high timeout
    tools_thd.join(timeout)


    if not tools_thd.isAlive():
        return True


    _logger.error('Timeout waiting for VMWare Tools to start.' +
                  'Make sure your virtual machine boots up corectly' +
                  'and that you have VMWare Tools installed.')

    with open(error_fname, 'a') as handler:
        print >> handler, 'Timeout waiting for VMWare Tools to start.\n' + \
                  'Make sure your virtual machine boots up corectly\n' + \
                  'and that you have VMWare Tools installed.\n'
    return False

def powerOn():
    hostRun("lxc-start -n deb1 -d")
    while True:
        o = hostRun("lxc-info -n deb1")
        if not "-1" in o:
            return

def power_on_with_message_handler(vm, vmwarecfg, vmx_path):
    """Powers on virtual machine and answers any input
       messages that might appear. """
    # vm.powerOn()
    # TODO
    power_thd = Thread(target = powerOn)
    power_thd.start()
    power_thd.join(5)

    if not power_thd.isAlive():
        # vm.powerOn() didn't hang: the machine has been powered on
        return
    else:
        print "LXC - wasn't powered on"

    # we might have an unanswered message waiting.
    # Start the message handler until the machine powers on.

    # XXX: This is currently a bash script, it should be
    # integrated as a module
    proc = Popen(['vmchecker-vm-message-handler',
                  vmwarecfg.vmware_hostname(),
                  vmwarecfg.vmware_username(),
                  vmwarecfg.vmware_password(),
                  vmwarecfg.vmware_rel_vmx_path(vmx_path)])
    os.waitpid(proc.pid, 0)
    # By now all the messages have been handled.
    # Wait for the VM to power on
    power_thd.join()



def power_off_and_unregister(vm, host, vmwarecfg, vmx_path):
    """ Power off the virtual machine and, if necessary, unregister it. """
    try:
        #vm.powerOff()
        hostRun("lxc-stop -n deb1")
    except Exception:
        _logger.exception('IGNORED EXCEPTION')
        pass
    if vmwarecfg.vmware_register_and_unregister():
        try:
            # host.unregisterVM(vmwarecfg.vmware_rel_vmx_path(vmx_path))
            pass
        except:
            _logger.exception('IGNORED EXCEPTION')
            pass
            


def try_power_on_vm_and_login(vm, vmwarecfg, machinecfg, assignment, asscfg, bundle_dir, vmx_path):
    """Power on the virtual machine taking care of possbile messages
       and handle the case in which the virtual machine doesn't have
       VMWare Tools installed or the username and password given are
       wrong."""

    error_fname = os.path.join(bundle_dir, 'vmchecker-stderr.vmr')
    tools_timeout = asscfg.delay_wait_for_tools(assignment)

    if asscfg.revert_to_snapshot(assignment):
        # revert to the last snapshot
        #revertToSnapshot(vm, None)
        vm.revert()

    power_on_with_message_handler(vm, vmwarecfg, vmx_path)
    if not wait_for_tools_with_timeout(vm, tools_timeout, error_fname):
        # no tools, nothing to do.
        return False

    try:
        #hostRun("lxc-start -n deb1 -d")
        pass #vm.loginInGuest(machinecfg.guest_user(), machinecfg.guest_pass())
    except Exception:
        _logger.error('Error logging in on the virtual machine.' +
                      'Make sure you have the accounts properly configured.')
        with open(error_fname, 'a') as handler:
            print >> handler,'Error logging in on the virtual machine.\n' + \
                    'Make sure you have the user accounts properly configured.\n'
            return False

    time.sleep(asscfg.delay_between_tools_and_tests(assignment))
    return True


def get_submission_vmx_file(bundle_dir):
    """Unzip search the bundle_dir and locate the .vmx file, no matter
    in what sub-folders it is located in. If the unzipped archive has
    multiple .vmx files, just pick the first.

    """
    for (root, _, files) in os.walk(bundle_dir):
        for f in files:
            if f.endswith(".vmx"):
                return os.path.join(root, f)
    return None


def test_submission(bundle_dir, vmcfg, assignment):
    """THE function that tests a submission bundle:
        * opens the vm and reverts to a known snapshot
        * prepares environments and executes all tests
        * manages kernel messages
    """
    asscfg  = vmcfg.assignments()
    timeout = asscfg.get(assignment, 'Timeout')
    machine = asscfg.get(assignment, 'Machine')
    machinecfg = VmwareMachineConfig(vmcfg, machine)
    print "@"+machinecfg.get_tester_id()
    vmwarecfg = VmwareConfig(vmcfg.testers(), machinecfg.get_tester_id())
    error_fname = os.path.join(bundle_dir, 'vmchecker-stderr.vmr')
    
    print machinecfg.get_vmx_path()
    print machinecfg.get_type()


    # try to get the machine's configuration, or the one uploaded by the student.
    vmx_path = machinecfg.get_vmx_path()
    if vmx_path == None:
        vmx_path = get_submission_vmx_file(bundle_dir)
    if vmx_path == None:
        # no vmx, nothing to do.
        _logger.error('Could not find a vmx to run')
        with open(error_fname, 'a') as handler:
            print >> handler, 'Error powering on the virtual machine.\n' + \
	    		'Unable to find .vmx file.\n'
        sys.exit(1) 
    
    h = LXCHost()
    g = h.getVM(machinecfg)
    g.start()
    g.stop()


    host = h
    vm = g
    success = try_power_on_vm_and_login(vm, vmwarecfg, machinecfg, assignment,
                                        asscfg, bundle_dir, vmx_path)
    if not success:
        _logger.error('Could not power on or login on the VM')
        power_off_and_unregister(vm, host, vmwarecfg, vmx_path)
        sys.exit(1)


    # start host commands
    host_command = vmcfg.get(machine, 'HostCommand', default='')
    host_command_data = start_host_commands(bundle_dir, host_command)

    try:
        # XXX: TODO: start km_command!!!
        km_command = vmcfg.get(machine, 'KernelMessages', default='')

        if asscfg.getd(assignment, 'assignmentstorage', '').lower() != 'large':
            # normal submissions will run tests the old way:
            # - upload test and user's submission archive and build them
            # - run the tests.
            buildcfg = {
                'input'  : ['archive.zip', 'tests.zip'],
                'script' : ['build.sh'],
                'output' : ['build-stdout.vmr', 'build-stderr.vmr'],
                'timeout': int(timeout),
                }
            print 'here'
            if not copy_files_and_run_script(vm, bundle_dir, machinecfg, buildcfg):
                return
        
            testcfg = {
                'input'  : [],
                'script' : ['run.sh'],
                'output' : ['run-stdout.vmr', 'run-stderr.vmr'],
                'timeout': int(timeout)
                }
            print 'here2'
            copy_files_and_run_script(vm, bundle_dir, machinecfg, testcfg)
        else:
            # large submissions don't send the archive to the virtual machine
            # (the virtual machine is actually part of the unpacked archive)
            testcfg = {
                'input'  : ['tests.zip'],
                'script' : ['run.sh'],
                'output' : ['run-stdout.vmr', 'run-stderr.vmr'],
                'timeout': int(timeout)
                }
            copy_files_and_run_script(vm, bundle_dir, machinecfg, testcfg)
    except Exception:
        _logger.exception('FUCK! Exception!RUUUUUUUN!!!')
    finally:
        stop_host_commands(host_command_data)
        power_off_and_unregister(vm, host, vmwarecfg, vmx_path)


def _check_required_files(path):
    """Checks that a set of files required by commander is present in
    the given path."""
    found_all = True
    needed_files = ['archive.zip', 'tests.zip', 'submission-config', 'course-config']
    found_files = os.listdir(path)
    not_found = []
    for need in needed_files:
        if not need in found_files:
            _logger.error('Could not find necessary file [%s] in [%s]' % (
                    need, path))
            found_all = False
            not_found.append(need)
    if not found_all:
        raise IOError('Files ' + json.dumps(not_found) + ' required for testing missing')


def get_assignment_id(bundle_dir):
    """Reads the assignment identifier from the config file of the
    submission from bundle_dir"""
    sb_config = os.path.join(bundle_dir, 'submission-config')
    with open(sb_config) as handle:
        config = ConfigParser.RawConfigParser()
        config.readfp(handle)
    assignment = config.get('Assignment', 'Assignment')
    return assignment


def main():
    """Main entry point when run as a script.

    Requires as an argument the path to a directory containing a bundle.

    The bundle must have:
      - archive.zip
      - tests.zip
      - submission-config
      - course-config
      - build and run scripts.
    """
    logging.basicConfig(level=logging.INFO)

    if len(sys.argv) != 2:
        print len(sys.argv)
        _logger.error('Usage: %s bundle_dir_location' % sys.argv[0])
        sys.exit(1)

    bundle_dir = sys.argv[1]
    _check_required_files(bundle_dir)
    vmcfg = CourseConfig(os.path.join(bundle_dir, 'course-config'))
    assignment = get_assignment_id(bundle_dir)
    print "ass id: "+assignment
    test_submission(bundle_dir, vmcfg, assignment)

    # some vmware calls may block indefinetly.  if we don't exit
    # explicitly, we may never return (this is due to python waiting
    # for all threads to exit, but some threads may be stuck in a
    # blocking vmware vix call.
    sys.exit(0)

def guestRun(cmd):
    """ runs the command inside the lxc container """
    p = Popen(["ssh root@deb1 "+cmd], stdout=PIPE,shell=True)
    output = p.stdout.read()
    print "--- RUN GUEST --\n"+cmd
    print "--- GUEST: --\n"+output+"\n---\n"
    return output

def hostRun(cmd):
    """ runs the command on the host """
    p = Popen([cmd],stdout=PIPE,shell=True)
    output = p.stdout.read()
    print "--- RUN HOST --\n"+cmd
    print "--- HOST: --\n"+output+"\n---\n"
    return output

if __name__ == "__main__":
    main()
